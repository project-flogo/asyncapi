// Code generated by schema-generate. DO NOT EDIT.

package models

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// APIKeyHTTPSecurityScheme
type APIKeyHTTPSecurityScheme struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	In                   string                 `json:"in"`
	Name                 string                 `json:"name"`
	Type                 string                 `json:"type"`
}

// ApiKey
type ApiKey struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	In                   string                 `json:"in"`
	Type                 string                 `json:"type"`
}

// AsymmetricEncryption
type AsymmetricEncryption struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Type                 string                 `json:"type"`
}

// AsyncAPI200Schema
type AsyncAPI200Schema struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`

	// The AsyncAPI specification version of this document.
	Asyncapi           string        `json:"asyncapi"`
	Channels           *Channels     `json:"channels"`
	Components         *Components   `json:"components,omitempty"`
	DefaultContentType string        `json:"defaultContentType,omitempty"`
	ExternalDocs       *ExternalDocs `json:"externalDocs,omitempty"`

	// A unique id representing the application.
	Id      string             `json:"id,omitempty"`
	Info    *Info              `json:"info"`
	Servers map[string]*Server `json:"servers,omitempty"`
	Tags    []*Tag             `json:"tags,omitempty"`
}

// BearerHTTPSecurityScheme
type BearerHTTPSecurityScheme struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	BearerFormat         string                 `json:"bearerFormat,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Scheme               string                 `json:"scheme"`
	Type                 string                 `json:"type"`
}

// BindingsObject
type BindingsObject struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Amqp                 interface{}            `json:"amqp,omitempty"`
	Amqp1                interface{}            `json:"amqp1,omitempty"`
	Http                 interface{}            `json:"http,omitempty"`
	Jms                  interface{}            `json:"jms,omitempty"`
	Kafka                interface{}            `json:"kafka,omitempty"`
	Mqtt                 interface{}            `json:"mqtt,omitempty"`
	Mqtt5                interface{}            `json:"mqtt5,omitempty"`
	Nats                 interface{}            `json:"nats,omitempty"`
	Redis                interface{}            `json:"redis,omitempty"`
	Sns                  interface{}            `json:"sns,omitempty"`
	Sqs                  interface{}            `json:"sqs,omitempty"`
	Stomp                interface{}            `json:"stomp,omitempty"`
	Ws                   interface{}            `json:"ws,omitempty"`
}

// ChannelItem
type ChannelItem struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Bindings             *BindingsObject        `json:"bindings,omitempty"`
	Deprecated           bool                   `json:"deprecated,omitempty"`

	// A description of the channel.
	Description string                `json:"description,omitempty"`
	Parameters  map[string]*Parameter `json:"parameters,omitempty"`
	Publish     *Operation            `json:"publish,omitempty"`
	Ref         string                `json:"$ref,omitempty"`
	Subscribe   *Operation            `json:"subscribe,omitempty"`
}

// Channels
type Channels struct {
	AdditionalProperties map[string]*ChannelItem `json:"-,omitempty"`
}

// Components An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.
type Components struct {
	AdditionalProperties map[string]interface{}     `json:"-,omitempty"`
	ChannelBindings      map[string]*BindingsObject `json:"channelBindings,omitempty"`
	CorrelationIds       *CorrelationIds            `json:"correlationIds,omitempty"`
	MessageBindings      map[string]*BindingsObject `json:"messageBindings,omitempty"`
	MessageTraits        map[string]*MessageTrait   `json:"messageTraits,omitempty"`
	Messages             *Messages                  `json:"messages,omitempty"`
	OperationBindings    map[string]*BindingsObject `json:"operationBindings,omitempty"`
	OperationTraits      map[string]*OperationTrait `json:"operationTraits,omitempty"`
	Parameters           *Parameters                `json:"parameters,omitempty"`
	Schemas              *Schemas                   `json:"schemas,omitempty"`
	SecuritySchemes      *SecuritySchemes           `json:"securitySchemes,omitempty"`
	ServerBindings       map[string]*BindingsObject `json:"serverBindings,omitempty"`
}

// Contact Contact information for the owners of the API.
type Contact struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`

	// The email address of the contact person/organization.
	Email string `json:"email,omitempty"`

	// The identifying name of the contact person/organization.
	Name string `json:"name,omitempty"`

	// The URL pointing to the contact information.
	Url string `json:"url,omitempty"`
}

// CorrelationId
type CorrelationId struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`

	// A optional description of the correlation ID. GitHub Flavored Markdown is allowed.
	Description string `json:"description,omitempty"`

	// A runtime expression that specifies the location of the correlation ID
	Location string `json:"location"`
}

// CorrelationIds
type CorrelationIds struct {
}

// ExamplesItems
type ExamplesItems struct {
}

// ExternalDocs information about external documentation
type ExternalDocs struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Url                  string                 `json:"url"`
}

// Flows
type Flows struct {
	AuthorizationCode interface{} `json:"authorizationCode,omitempty"`
	ClientCredentials interface{} `json:"clientCredentials,omitempty"`
	Implicit          interface{} `json:"implicit,omitempty"`
	Password          interface{} `json:"password,omitempty"`
}

// Info General information about the API.
type Info struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Contact              *Contact               `json:"contact,omitempty"`

	// A longer description of the API. Should be different from the title. CommonMark is allowed.
	Description string   `json:"description,omitempty"`
	License     *License `json:"license,omitempty"`

	// A URL to the Terms of Service for the API. MUST be in the format of a URL.
	TermsOfService string `json:"termsOfService,omitempty"`

	// A unique and precise title of the API.
	Title string `json:"title"`

	// A semantic version number of the API.
	Version string `json:"version"`
}

// License
type License struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`

	// The name of the license type. It's encouraged to use an OSI compatible license.
	Name string `json:"name"`

	// The URL pointing to the license.
	Url string `json:"url,omitempty"`
}

// MessageTrait
type MessageTrait struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Bindings             *BindingsObject        `json:"bindings,omitempty"`
	ContentType          string                 `json:"contentType,omitempty"`
	CorrelationId        interface{}            `json:"correlationId,omitempty"`
	Deprecated           bool                   `json:"deprecated,omitempty"`

	// A longer description of the message. CommonMark is allowed.
	Description  string           `json:"description,omitempty"`
	Examples     []*ExamplesItems `json:"examples,omitempty"`
	ExternalDocs *ExternalDocs    `json:"externalDocs,omitempty"`
	Headers      interface{}      `json:"headers,omitempty"`

	// Name of the message.
	Name         string `json:"name,omitempty"`
	SchemaFormat string `json:"schemaFormat,omitempty"`

	// A brief summary of the message.
	Summary string `json:"summary,omitempty"`
	Tags    []*Tag `json:"tags,omitempty"`

	// A human-friendly title for the message.
	Title string `json:"title,omitempty"`
}

// Messages JSON objects describing the messages being consumed and produced by the API.
type Messages struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// NonBearerHTTPSecurityScheme
type NonBearerHTTPSecurityScheme struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Scheme               string                 `json:"scheme"`
	Type                 string                 `json:"type"`
}

// Oauth2Flow
type Oauth2Flow struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	AuthorizationUrl     string                 `json:"authorizationUrl,omitempty"`
	RefreshUrl           string                 `json:"refreshUrl,omitempty"`
	Scopes               *Oauth2Scopes          `json:"scopes,omitempty"`
	TokenUrl             string                 `json:"tokenUrl,omitempty"`
}

// Oauth2Flows
type Oauth2Flows struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Flows                *Flows                 `json:"flows"`
	Type                 string                 `json:"type"`
}

// Oauth2Scopes
type Oauth2Scopes struct {
	AdditionalProperties map[string]string `json:"-,omitempty"`
}

// OpenIdConnect
type OpenIdConnect struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	OpenIdConnectUrl     string                 `json:"openIdConnectUrl"`
	Type                 string                 `json:"type"`
}

// Operation
type Operation struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Bindings             *BindingsObject        `json:"bindings,omitempty"`
	Description          string                 `json:"description,omitempty"`
	ExternalDocs         *ExternalDocs          `json:"externalDocs,omitempty"`
	Message              interface{}            `json:"message,omitempty"`
	OperationId          string                 `json:"operationId,omitempty"`
	Summary              string                 `json:"summary,omitempty"`
	Tags                 []*Tag                 `json:"tags,omitempty"`
	Traits               []interface{}          `json:"traits,omitempty"`
}

// OperationTrait
type OperationTrait struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Bindings             *BindingsObject        `json:"bindings,omitempty"`
	Description          string                 `json:"description,omitempty"`
	ExternalDocs         *ExternalDocs          `json:"externalDocs,omitempty"`
	OperationId          string                 `json:"operationId,omitempty"`
	Summary              string                 `json:"summary,omitempty"`
	Tags                 []*Tag                 `json:"tags,omitempty"`
}

// Parameter
type Parameter struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`

	// A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed.
	Description string `json:"description,omitempty"`

	// A runtime expression that specifies the location of the parameter value
	Location string      `json:"location,omitempty"`
	Ref      string      `json:"$ref,omitempty"`
	Schema   interface{} `json:"schema,omitempty"`
}

// Parameters JSON objects describing re-usable channel parameters.
type Parameters struct {
	AdditionalProperties map[string]*Parameter `json:"-,omitempty"`
}

// Reference
type Reference struct {
	Ref string `json:"$ref"`
}

// Schemas JSON objects describing schemas the API uses.
type Schemas struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// SecurityRequirement
type SecurityRequirement struct {
	AdditionalProperties map[string][]string `json:"-,omitempty"`
}

// SecuritySchemes
type SecuritySchemes struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// Server An object representing a Server.
type Server struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Bindings             *BindingsObject        `json:"bindings,omitempty"`
	Description          string                 `json:"description,omitempty"`

	// The transfer protocol.
	Protocol        string                 `json:"protocol"`
	ProtocolVersion string                 `json:"protocolVersion,omitempty"`
	Security        []*SecurityRequirement `json:"security,omitempty"`
	Url             string                 `json:"url"`
	Variables       *ServerVariables       `json:"variables,omitempty"`
}

// ServerVariable An object representing a Server Variable for server URL template substitution.
type ServerVariable struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Default              string                 `json:"default,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Enum                 []string               `json:"enum,omitempty"`
	Examples             []string               `json:"examples,omitempty"`
}

// ServerVariables
type ServerVariables struct {
	AdditionalProperties map[string]*ServerVariable `json:"-,omitempty"`
}

// SymmetricEncryption
type SymmetricEncryption struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Type                 string                 `json:"type"`
}

// Tag
type Tag struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	ExternalDocs         *ExternalDocs          `json:"externalDocs,omitempty"`
	Name                 string                 `json:"name"`
}

// UserPassword
type UserPassword struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Type                 string                 `json:"type"`
}

// X509
type X509 struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Description          string                 `json:"description,omitempty"`
	Type                 string                 `json:"type"`
}

func (strct *APIKeyHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "In" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "in" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *APIKeyHTTPSecurityScheme) UnmarshalJSON(b []byte) error {
	inReceived := false
	nameReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "in":
			if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
				return err
			}
			inReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if in (a required property) was received
	if !inReceived {
		return errors.New("\"in\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *ApiKey) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "In" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "in" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApiKey) UnmarshalJSON(b []byte) error {
	inReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "in":
			if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
				return err
			}
			inReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if in (a required property) was received
	if !inReceived {
		return errors.New("\"in\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *AsymmetricEncryption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AsymmetricEncryption) UnmarshalJSON(b []byte) error {
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *AsyncAPI200Schema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Asyncapi" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "asyncapi" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"asyncapi\": ")
	if tmp, err := json.Marshal(strct.Asyncapi); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Channels" field is required
	if strct.Channels == nil {
		return nil, errors.New("channels is a required field")
	}
	// Marshal the "channels" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channels\": ")
	if tmp, err := json.Marshal(strct.Channels); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "components" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"components\": ")
	if tmp, err := json.Marshal(strct.Components); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "defaultContentType" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"defaultContentType\": ")
	if tmp, err := json.Marshal(strct.DefaultContentType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "externalDocs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "id" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Info" field is required
	if strct.Info == nil {
		return nil, errors.New("info is a required field")
	}
	// Marshal the "info" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"info\": ")
	if tmp, err := json.Marshal(strct.Info); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "servers" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"servers\": ")
	if tmp, err := json.Marshal(strct.Servers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tags" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AsyncAPI200Schema) UnmarshalJSON(b []byte) error {
	asyncapiReceived := false
	channelsReceived := false
	infoReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "asyncapi":
			if err := json.Unmarshal([]byte(v), &strct.Asyncapi); err != nil {
				return err
			}
			asyncapiReceived = true
		case "channels":
			if err := json.Unmarshal([]byte(v), &strct.Channels); err != nil {
				return err
			}
			channelsReceived = true
		case "components":
			if err := json.Unmarshal([]byte(v), &strct.Components); err != nil {
				return err
			}
		case "defaultContentType":
			if err := json.Unmarshal([]byte(v), &strct.DefaultContentType); err != nil {
				return err
			}
		case "externalDocs":
			if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
				return err
			}
		case "id":
			if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
			}
		case "info":
			if err := json.Unmarshal([]byte(v), &strct.Info); err != nil {
				return err
			}
			infoReceived = true
		case "servers":
			if err := json.Unmarshal([]byte(v), &strct.Servers); err != nil {
				return err
			}
		case "tags":
			if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if asyncapi (a required property) was received
	if !asyncapiReceived {
		return errors.New("\"asyncapi\" is required but was not present")
	}
	// check if channels (a required property) was received
	if !channelsReceived {
		return errors.New("\"channels\" is required but was not present")
	}
	// check if info (a required property) was received
	if !infoReceived {
		return errors.New("\"info\" is required but was not present")
	}
	return nil
}

func (strct *BearerHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bearerFormat" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bearerFormat\": ")
	if tmp, err := json.Marshal(strct.BearerFormat); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Scheme" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "scheme" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"scheme\": ")
	if tmp, err := json.Marshal(strct.Scheme); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BearerHTTPSecurityScheme) UnmarshalJSON(b []byte) error {
	schemeReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bearerFormat":
			if err := json.Unmarshal([]byte(v), &strct.BearerFormat); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "scheme":
			if err := json.Unmarshal([]byte(v), &strct.Scheme); err != nil {
				return err
			}
			schemeReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if scheme (a required property) was received
	if !schemeReceived {
		return errors.New("\"scheme\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *BindingsObject) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "amqp" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"amqp\": ")
	if tmp, err := json.Marshal(strct.Amqp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "amqp1" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"amqp1\": ")
	if tmp, err := json.Marshal(strct.Amqp1); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "http" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"http\": ")
	if tmp, err := json.Marshal(strct.Http); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "jms" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"jms\": ")
	if tmp, err := json.Marshal(strct.Jms); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "kafka" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"kafka\": ")
	if tmp, err := json.Marshal(strct.Kafka); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "mqtt" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mqtt\": ")
	if tmp, err := json.Marshal(strct.Mqtt); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "mqtt5" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mqtt5\": ")
	if tmp, err := json.Marshal(strct.Mqtt5); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "nats" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nats\": ")
	if tmp, err := json.Marshal(strct.Nats); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "redis" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"redis\": ")
	if tmp, err := json.Marshal(strct.Redis); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sns" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sns\": ")
	if tmp, err := json.Marshal(strct.Sns); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sqs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sqs\": ")
	if tmp, err := json.Marshal(strct.Sqs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "stomp" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"stomp\": ")
	if tmp, err := json.Marshal(strct.Stomp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "ws" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"ws\": ")
	if tmp, err := json.Marshal(strct.Ws); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BindingsObject) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "amqp":
			if err := json.Unmarshal([]byte(v), &strct.Amqp); err != nil {
				return err
			}
		case "amqp1":
			if err := json.Unmarshal([]byte(v), &strct.Amqp1); err != nil {
				return err
			}
		case "http":
			if err := json.Unmarshal([]byte(v), &strct.Http); err != nil {
				return err
			}
		case "jms":
			if err := json.Unmarshal([]byte(v), &strct.Jms); err != nil {
				return err
			}
		case "kafka":
			if err := json.Unmarshal([]byte(v), &strct.Kafka); err != nil {
				return err
			}
		case "mqtt":
			if err := json.Unmarshal([]byte(v), &strct.Mqtt); err != nil {
				return err
			}
		case "mqtt5":
			if err := json.Unmarshal([]byte(v), &strct.Mqtt5); err != nil {
				return err
			}
		case "nats":
			if err := json.Unmarshal([]byte(v), &strct.Nats); err != nil {
				return err
			}
		case "redis":
			if err := json.Unmarshal([]byte(v), &strct.Redis); err != nil {
				return err
			}
		case "sns":
			if err := json.Unmarshal([]byte(v), &strct.Sns); err != nil {
				return err
			}
		case "sqs":
			if err := json.Unmarshal([]byte(v), &strct.Sqs); err != nil {
				return err
			}
		case "stomp":
			if err := json.Unmarshal([]byte(v), &strct.Stomp); err != nil {
				return err
			}
		case "ws":
			if err := json.Unmarshal([]byte(v), &strct.Ws); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *ChannelItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bindings\": ")
	if tmp, err := json.Marshal(strct.Bindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "deprecated" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "parameters" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "publish" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"publish\": ")
	if tmp, err := json.Marshal(strct.Publish); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "$ref" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "subscribe" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"subscribe\": ")
	if tmp, err := json.Marshal(strct.Subscribe); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChannelItem) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bindings":
			if err := json.Unmarshal([]byte(v), &strct.Bindings); err != nil {
				return err
			}
		case "deprecated":
			if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "parameters":
			if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
				return err
			}
		case "publish":
			if err := json.Unmarshal([]byte(v), &strct.Publish); err != nil {
				return err
			}
		case "$ref":
			if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
				return err
			}
		case "subscribe":
			if err := json.Unmarshal([]byte(v), &strct.Subscribe); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Channels) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Channels) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "*ChannelItem" value
			var additionalValue *ChannelItem
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]*ChannelItem, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Components) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "channelBindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channelBindings\": ")
	if tmp, err := json.Marshal(strct.ChannelBindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "correlationIds" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"correlationIds\": ")
	if tmp, err := json.Marshal(strct.CorrelationIds); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "messageBindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"messageBindings\": ")
	if tmp, err := json.Marshal(strct.MessageBindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "messageTraits" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"messageTraits\": ")
	if tmp, err := json.Marshal(strct.MessageTraits); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "messages" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"messages\": ")
	if tmp, err := json.Marshal(strct.Messages); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "operationBindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"operationBindings\": ")
	if tmp, err := json.Marshal(strct.OperationBindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "operationTraits" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"operationTraits\": ")
	if tmp, err := json.Marshal(strct.OperationTraits); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "parameters" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "schemas" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"schemas\": ")
	if tmp, err := json.Marshal(strct.Schemas); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "securitySchemes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"securitySchemes\": ")
	if tmp, err := json.Marshal(strct.SecuritySchemes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "serverBindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"serverBindings\": ")
	if tmp, err := json.Marshal(strct.ServerBindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Components) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "channelBindings":
			if err := json.Unmarshal([]byte(v), &strct.ChannelBindings); err != nil {
				return err
			}
		case "correlationIds":
			if err := json.Unmarshal([]byte(v), &strct.CorrelationIds); err != nil {
				return err
			}
		case "messageBindings":
			if err := json.Unmarshal([]byte(v), &strct.MessageBindings); err != nil {
				return err
			}
		case "messageTraits":
			if err := json.Unmarshal([]byte(v), &strct.MessageTraits); err != nil {
				return err
			}
		case "messages":
			if err := json.Unmarshal([]byte(v), &strct.Messages); err != nil {
				return err
			}
		case "operationBindings":
			if err := json.Unmarshal([]byte(v), &strct.OperationBindings); err != nil {
				return err
			}
		case "operationTraits":
			if err := json.Unmarshal([]byte(v), &strct.OperationTraits); err != nil {
				return err
			}
		case "parameters":
			if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
				return err
			}
		case "schemas":
			if err := json.Unmarshal([]byte(v), &strct.Schemas); err != nil {
				return err
			}
		case "securitySchemes":
			if err := json.Unmarshal([]byte(v), &strct.SecuritySchemes); err != nil {
				return err
			}
		case "serverBindings":
			if err := json.Unmarshal([]byte(v), &strct.ServerBindings); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Contact) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "email" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"email\": ")
	if tmp, err := json.Marshal(strct.Email); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Contact) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "email":
			if err := json.Unmarshal([]byte(v), &strct.Email); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *CorrelationId) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CorrelationId) UnmarshalJSON(b []byte) error {
	locationReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	return nil
}

func (strct *ExternalDocs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExternalDocs) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Flows) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "authorizationCode" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"authorizationCode\": ")
	if tmp, err := json.Marshal(strct.AuthorizationCode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "clientCredentials" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"clientCredentials\": ")
	if tmp, err := json.Marshal(strct.ClientCredentials); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "implicit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"implicit\": ")
	if tmp, err := json.Marshal(strct.Implicit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "password" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Flows) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "authorizationCode":
			if err := json.Unmarshal([]byte(v), &strct.AuthorizationCode); err != nil {
				return err
			}
		case "clientCredentials":
			if err := json.Unmarshal([]byte(v), &strct.ClientCredentials); err != nil {
				return err
			}
		case "implicit":
			if err := json.Unmarshal([]byte(v), &strct.Implicit); err != nil {
				return err
			}
		case "password":
			if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}

func (strct *Info) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "contact" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "license" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"license\": ")
	if tmp, err := json.Marshal(strct.License); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "termsOfService" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"termsOfService\": ")
	if tmp, err := json.Marshal(strct.TermsOfService); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Title" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "title" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Version" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "version" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Info) UnmarshalJSON(b []byte) error {
	titleReceived := false
	versionReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "contact":
			if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "license":
			if err := json.Unmarshal([]byte(v), &strct.License); err != nil {
				return err
			}
		case "termsOfService":
			if err := json.Unmarshal([]byte(v), &strct.TermsOfService); err != nil {
				return err
			}
		case "title":
			if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
				return err
			}
			titleReceived = true
		case "version":
			if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
				return err
			}
			versionReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if title (a required property) was received
	if !titleReceived {
		return errors.New("\"title\" is required but was not present")
	}
	// check if version (a required property) was received
	if !versionReceived {
		return errors.New("\"version\" is required but was not present")
	}
	return nil
}

func (strct *License) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *License) UnmarshalJSON(b []byte) error {
	nameReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	return nil
}

func (strct *MessageTrait) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bindings\": ")
	if tmp, err := json.Marshal(strct.Bindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "contentType" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"contentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "correlationId" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"correlationId\": ")
	if tmp, err := json.Marshal(strct.CorrelationId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "deprecated" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "examples" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "externalDocs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "headers" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "schemaFormat" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"schemaFormat\": ")
	if tmp, err := json.Marshal(strct.SchemaFormat); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "summary" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tags" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "title" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MessageTrait) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bindings":
			if err := json.Unmarshal([]byte(v), &strct.Bindings); err != nil {
				return err
			}
		case "contentType":
			if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
				return err
			}
		case "correlationId":
			if err := json.Unmarshal([]byte(v), &strct.CorrelationId); err != nil {
				return err
			}
		case "deprecated":
			if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "examples":
			if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
				return err
			}
		case "externalDocs":
			if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
				return err
			}
		case "headers":
			if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "schemaFormat":
			if err := json.Unmarshal([]byte(v), &strct.SchemaFormat); err != nil {
				return err
			}
		case "summary":
			if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
				return err
			}
		case "tags":
			if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
				return err
			}
		case "title":
			if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Messages) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Messages) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *NonBearerHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Scheme" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "scheme" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"scheme\": ")
	if tmp, err := json.Marshal(strct.Scheme); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonBearerHTTPSecurityScheme) UnmarshalJSON(b []byte) error {
	schemeReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "scheme":
			if err := json.Unmarshal([]byte(v), &strct.Scheme); err != nil {
				return err
			}
			schemeReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if scheme (a required property) was received
	if !schemeReceived {
		return errors.New("\"scheme\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *Oauth2Flow) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "authorizationUrl" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "refreshUrl" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "scopes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tokenUrl" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2Flow) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "authorizationUrl":
			if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
				return err
			}
		case "refreshUrl":
			if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
				return err
			}
		case "scopes":
			if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
				return err
			}
		case "tokenUrl":
			if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Oauth2Flows) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Flows" field is required
	if strct.Flows == nil {
		return nil, errors.New("flows is a required field")
	}
	// Marshal the "flows" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"flows\": ")
	if tmp, err := json.Marshal(strct.Flows); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2Flows) UnmarshalJSON(b []byte) error {
	flowsReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "flows":
			if err := json.Unmarshal([]byte(v), &strct.Flows); err != nil {
				return err
			}
			flowsReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if flows (a required property) was received
	if !flowsReceived {
		return errors.New("\"flows\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *Oauth2Scopes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2Scopes) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "string" value
			var additionalValue string
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]string, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *OpenIdConnect) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "OpenIdConnectUrl" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "openIdConnectUrl" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"openIdConnectUrl\": ")
	if tmp, err := json.Marshal(strct.OpenIdConnectUrl); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OpenIdConnect) UnmarshalJSON(b []byte) error {
	openIdConnectUrlReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "openIdConnectUrl":
			if err := json.Unmarshal([]byte(v), &strct.OpenIdConnectUrl); err != nil {
				return err
			}
			openIdConnectUrlReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if openIdConnectUrl (a required property) was received
	if !openIdConnectUrlReceived {
		return errors.New("\"openIdConnectUrl\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *Operation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bindings\": ")
	if tmp, err := json.Marshal(strct.Bindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "externalDocs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "message" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "operationId" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"operationId\": ")
	if tmp, err := json.Marshal(strct.OperationId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "summary" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tags" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "traits" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"traits\": ")
	if tmp, err := json.Marshal(strct.Traits); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Operation) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bindings":
			if err := json.Unmarshal([]byte(v), &strct.Bindings); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "externalDocs":
			if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
				return err
			}
		case "message":
			if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
				return err
			}
		case "operationId":
			if err := json.Unmarshal([]byte(v), &strct.OperationId); err != nil {
				return err
			}
		case "summary":
			if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
				return err
			}
		case "tags":
			if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
				return err
			}
		case "traits":
			if err := json.Unmarshal([]byte(v), &strct.Traits); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *OperationTrait) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bindings\": ")
	if tmp, err := json.Marshal(strct.Bindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "externalDocs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "operationId" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"operationId\": ")
	if tmp, err := json.Marshal(strct.OperationId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "summary" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "tags" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OperationTrait) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bindings":
			if err := json.Unmarshal([]byte(v), &strct.Bindings); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "externalDocs":
			if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
				return err
			}
		case "operationId":
			if err := json.Unmarshal([]byte(v), &strct.OperationId); err != nil {
				return err
			}
		case "summary":
			if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
				return err
			}
		case "tags":
			if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Parameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "$ref" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "schema" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameter) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "$ref":
			if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
				return err
			}
		case "schema":
			if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Parameters) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameters) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "*Parameter" value
			var additionalValue *Parameter
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]*Parameter, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Reference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Ref" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "$ref" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Reference) UnmarshalJSON(b []byte) error {
	refReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "$ref":
			if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
				return err
			}
			refReceived = true
		}
	}
	// check if $ref (a required property) was received
	if !refReceived {
		return errors.New("\"$ref\" is required but was not present")
	}
	return nil
}

func (strct *Schemas) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Schemas) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *SecurityRequirement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecurityRequirement) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "[]string" value
			var additionalValue []string
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string][]string, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *SecuritySchemes) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecuritySchemes) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *Server) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bindings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bindings\": ")
	if tmp, err := json.Marshal(strct.Bindings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Protocol" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "protocol" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"protocol\": ")
	if tmp, err := json.Marshal(strct.Protocol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "protocolVersion" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"protocolVersion\": ")
	if tmp, err := json.Marshal(strct.ProtocolVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "security" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"security\": ")
	if tmp, err := json.Marshal(strct.Security); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "variables" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Server) UnmarshalJSON(b []byte) error {
	protocolReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bindings":
			if err := json.Unmarshal([]byte(v), &strct.Bindings); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "protocol":
			if err := json.Unmarshal([]byte(v), &strct.Protocol); err != nil {
				return err
			}
			protocolReceived = true
		case "protocolVersion":
			if err := json.Unmarshal([]byte(v), &strct.ProtocolVersion); err != nil {
				return err
			}
		case "security":
			if err := json.Unmarshal([]byte(v), &strct.Security); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		case "variables":
			if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if protocol (a required property) was received
	if !protocolReceived {
		return errors.New("\"protocol\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *ServerVariable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "default" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "enum" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "examples" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerVariable) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "default":
			if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "enum":
			if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
				return err
			}
		case "examples":
			if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
				return err
			}
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *ServerVariables) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerVariables) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "*ServerVariable" value
			var additionalValue *ServerVariable
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]*ServerVariable, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *SymmetricEncryption) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SymmetricEncryption) UnmarshalJSON(b []byte) error {
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "externalDocs" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
	nameReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "externalDocs":
			if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	return nil
}

func (strct *UserPassword) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *UserPassword) UnmarshalJSON(b []byte) error {
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *X509) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *X509) UnmarshalJSON(b []byte) error {
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}
